use std::fs::File;
use std::io::{Error, Write};

use crate::scripts::arrow_self;

const OVERWRITE: bool = false;

fn gen_file(name: &str, overwrite: bool) -> Result<File, Error> {
    let mut file = File::options()
        .create(true)
        .write(true)
        .create_new(!overwrite)
        .truncate(true)
        .open(format!("./battlelib/data/battle/functions/{}.mcfunction", name))?;
    file.write_all(b"# Generated by rust codes\n")?;
    Ok(file)
}

mod scripts {
    use std::io::{Error, Write};

    use crate::{gen_file, OVERWRITE};

    pub fn circles() -> Result<(), Error> {
        let mut rad = 0.5;
        while rad <= 25.0 {
            let mut file = gen_file(&format!("circle{:.1}", rad), OVERWRITE)?;
            let step = if rad <= 1.0 {
                10.0
            } else if rad <= 3.0 {
                5.0
            } else if rad <= 5.0 {
                4.0
            } else if rad <= 10.0 {
                2.0
            } else {
                1.0
            };

            let mut i = 0.0;
            while i < 360.0 {
                let (sin, cos) = ((i as f64) * std::f64::consts::PI / 180.0).sin_cos();
                let x = sin * rad as f64;
                let y = cos * rad as f64;
                let rx = -x;
                let ry = -y;
                writeln!(file, "execute positioned ~{x:.5} ~ ~{y:.5} facing ~{rx:.5} ~ ~{ry:.5} run function battleapi:circle_cb")?;
                i += step;
            }
            rad += 0.5;
        }
        Ok(())
    }

    pub fn arrow_self() -> Result<(), Error> {
        let mut file = gen_file("x2self", true)?;

        // \ | | /
        //  \| |/
        // --* *--
        //    o
        // --* *--
        //  /| |\
        // / | | \

        // draw axis
        for dis in (4..).map(|x| x as f64 * 0.25).take_while(|x| *x <= 2.5) {
            writeln!(file, "execute positioned ~{dis} ~ ~1 run function battleapi:x2self_cb")?;
            writeln!(file, "execute positioned ~-{dis} ~ ~1 run function battleapi:x2self_cb")?;
            writeln!(file, "execute positioned ~{dis} ~ ~-1 run function battleapi:x2self_cb")?;
            writeln!(file, "execute positioned ~-{dis} ~ ~-1 run function battleapi:x2self_cb")?;

            writeln!(file, "execute positioned ~1 ~ ~{dis} run function battleapi:x2self_cb")?;
            writeln!(file, "execute positioned ~1 ~ ~-{dis} run function battleapi:x2self_cb")?;
            writeln!(file, "execute positioned ~-1 ~ ~{dis} run function battleapi:x2self_cb")?;
            writeln!(file, "execute positioned ~-1 ~ ~-{dis} run function battleapi:x2self_cb")?;
        }
        // draw x
        let unit = 0.25 / 2.0_f64.sqrt();
        for dis in (6..).map(|x| x as f64 * unit).take_while(|x| *x * *x <= (5.0 / 2.0_f64.sqrt()).powi(2)) {
            writeln!(file, "execute positioned ~{dis:.5} ~ ~{dis:.5} run function battleapi:x2self_cb")?;
            writeln!(file, "execute positioned ~{dis:.5} ~ ~-{dis:.5} run function battleapi:x2self_cb")?;
            writeln!(file, "execute positioned ~-{dis:.5} ~ ~{dis:.5} run function battleapi:x2self_cb")?;
            writeln!(file, "execute positioned ~-{dis:.5} ~ ~-{dis:.5} run function battleapi:x2self_cb")?;
        }

        Ok(())
    }
}

fn main() {
    let ss = [scripts::circles, arrow_self];
    for f in ss {
        let result = std::panic::catch_unwind(|| {
            if let Err(e) = f() {
                eprintln!("One script failed for {:?}", e);
            } else {
                println!("Done one script");
            }
        });
        if let Err(e) = result {
            eprintln!("Panicked for {:?}", e);
        }
    }
}
